export type CustomDataType = 'proportion' | 'weight' | 'link_url' | 'link_title' | 'option' | 'value_type_id'
export type DataLiteral = string | number | boolean | null
export type DataOp = 'INSERT' | 'UPDATE' | 'DELETE'
export type ColumnType = 'boolean' | 'integer'

export interface DataRecord {[column: string]: DataLiteral }
export type DataRecordWithId = DataRecord & {id: number}

interface SharedColumnProps {
  label?: string
  preview?: boolean //Use this column to represent the whole record
  getVisibility?: (record: DataRecord) => boolean // determine if the field should be visible
  defaultValue?: DataLiteral
}

export interface SimpleColumn extends SharedColumnProps {
  type: 'integer' | 'varchar' | 'proportion' | 'weight' | 'link_url' | 'link_title'
}

export interface BooleanColumn extends SharedColumnProps {
  type: 'boolean'
  optionLabels?: [string, string]
}

export interface TextColumn extends SharedColumnProps {
  type: 'text'
  lines?: number
}

export interface OptionColumn extends SharedColumnProps {
  type: 'option',
  options: string[]
}

// NOTE: A lot of code is requered to implement this column type. Perhaps a simpler approach can be found.
export interface ValueTypeIdColumn extends SharedColumnProps {
  type: 'value_type_id',
  typeOriginColumn: string,
  getOriginTypesQuery: string,
  getTypeByOriginIdQuery: string,
  getTypeByRecordIdQuery: string
}

// It's values are not stored in db,
// but instead derevied from other values when the record is read
export interface VirtualColumnQueries extends SharedColumnProps {
  type: 'virtual',
  // queries that will be run with ids as the only parameter
  queries: Record<string, string>,
  // generate strings for every id from query resuls
  get: (ids: number[], results: Record<string, DataRecord[]>)
    => Record<number, string>
}

// The value of the column will be generated by a server function
// functions are stored in src/server/virtualColumns.ts
export interface VirtualColumnServerFn extends SharedColumnProps {
  type: 'virtual',
  serverFn: true
}

export interface VirtualColumnLocal extends SharedColumnProps {
  type: 'virtual',
  getLocal: (record: DataRecordWithId) => string
}

export interface ForeignKey {
  type: 'fk'
  label?: string
  preview?: boolean //Use this column to represent the whole record
  fk: {
    table: string 
    labelColumn: string
    extensionTables?: string[] // Choose extension table by appending the array element corresponding to the referenced id to the table name
    getLabel?: (record: DataRecord) => string // Generate label from the foreign record,
    defaultName?: string // the FK value should be set to id corresponding to this name by default
    optional?: boolean  // Foreign key can be NULL
  }
  getVisibility?: (record: DataRecord) => boolean
}

export type ColumnSchema = (SimpleColumn | BooleanColumn | TextColumn | ForeignKey | OptionColumn | ValueTypeIdColumn | VirtualColumnQueries | VirtualColumnServerFn | VirtualColumnLocal) & {
  readOnly?: true // ordinarily, this field should not be edited directly
  unique?: true
}

export interface OneToNSchema {
  type: '1-n'
  table: string
  column: string
  splitByColumn?: string
  filterSplitBy?: string // both parent and split tables should have this column and only overlapping entries will be shown
}

export interface NToNSchema {
  type: 'n-n'
  table: string
  first?: boolean // should the parent table appear first in the name of the cross table. Exactly one of the table pair should have this param set to true!
}

export type AggregateSchema = OneToNSchema | NToNSchema

interface Section {
  label: string
  private?: true,
  fields?: string[]
  component?: string
}

export interface TableSchema {
  plural?: string,
  private?: true,
  extendsTable?: string, // This table extends another table with its columns
  extendedByTable?: string, // This table is extended by another table
  preview?: (record: DataRecord) => string, // Text to represent the whole record
  columns: Record<string, ColumnSchema>
  aggregates?: Record<string, AggregateSchema>
  createRecord?: () => DataRecord // Generate new records automatically
  sections?: Record<string, Section>
  advanced?: string[] // Columns that are not shown by default when editing
}

export interface AppDataSchema {
  tables: Record<string, TableSchema>
}
